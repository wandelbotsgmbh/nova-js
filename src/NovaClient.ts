import type { Configuration } from "@wandelbots/wandelbots-api-client"
import { NovaCellAPIClient } from "./lib/NovaCellAPIClient"
import urlJoin from "url-join"
import { AutoReconnectingWebsocket } from "./lib/AutoReconnectingWebsocket"
import { AxiosRequestConfig, getAdapter } from "axios"
import { JoggerConnection } from "./lib/JoggerConnection"
import { MotionStreamConnection } from "./lib/MotionStreamConnection"
import { MockNovaInstance } from "./mock/MockNovaInstance"
import { ConnectedMotionGroup } from "./lib/ConnectedMotionGroup"

export type NovaClientConfig = {
  /**
   * Url of the deployed Nova instance to connect to
   * e.g. https://saeattii.instance.wandelbots.io
   */
  instanceUrl: string

  /**
   * Identifier of the cell on the Nova instance to connect this client to.
   * If omitted, the default identifier "cell" is used.
   **/
  cellId?: string

  /**
   * Username for basic auth to the Nova instance.
   */
  username?: string

  /**
   * Password for basic auth to the Nova instance.
   */
  password?: string

  /**
   * EXPERIMENTAL - For testing purposes. If true, the client won't connect to a Nova
   * instance at all, and will instead use its own internal, heavily simplified mock replica
   * to respond to requests.
   */
  mock?: boolean
} & Omit<Configuration, "isJsonMime" | "basePath">

type NovaClientConfigWithDefaults = NovaClientConfig & { cellId: string }

/**
 * Client for connecting to a Nova instance and controlling robots.
 */
export class NovaClient {
  readonly api: NovaCellAPIClient
  readonly config: NovaClientConfigWithDefaults
  readonly mock?: MockNovaInstance
  readonly websocketsByPath: Record<string, AutoReconnectingWebsocket> = {}

  constructor(config: NovaClientConfig) {
    const cellId = config.cellId ?? "cell"
    this.config = {
      cellId,
      ...config,
    }

    if (this.config.mock) {
      this.mock = new MockNovaInstance()
    }

    this.api = new NovaCellAPIClient(cellId, {
      ...config,
      basePath: urlJoin(this.config.instanceUrl, "/api/v1"),
      // Weird isJsonMime thing to work around bug in autogenerated API types
      isJsonMime: undefined as any,
      baseOptions: {
        ...(this.mock
          ? ({
              adapter: (config) => {
                return this.mock!.handleAPIRequest(config)
              },
            } satisfies AxiosRequestConfig)
          : {}),
        ...config.baseOptions,
        // Add basic auth to all axios requests if username and password are provided
        ...(config.username && config.password
          ? ({
              headers: {
                Authorization:
                  "Basic " + btoa(config.username + ":" + config.password),
              },
            } satisfies AxiosRequestConfig)
          : {}),
      },
    })
  }

  /**
   * Given a relative path on the Nova API for this cell, returns an absolute url
   * string suitable for websocket construction.
   */
  makeWebsocketURL(path: string): string {
    const url = new URL(
      urlJoin(
        this.config.instanceUrl,
        `/api/v1/cells/${this.config.cellId}`,
        path,
      ),
    )
    url.protocol = url.protocol.replace("http", "ws")
    url.protocol = url.protocol.replace("https", "wss")

    // If provided, add basic auth credentials to the URL
    // TODO - basic auth is deprecated on websockets and doesn't work in Safari
    // need a better solution on the backend
    if (this.config.username && this.config.password) {
      url.username = this.config.username
      url.password = this.config.password
    }

    return url.toString()
  }

  /**
   * Retrieve an AutoReconnectingWebsocket to the given path on the Nova instance.
   * If this client already has an open websocket to the path, the websocket will be
   * reused instead of opening a duplicate one.
   * If you explicitly want to reconnect an existing websocket, call `reconnect`
   * on the returned object.
   */
  openReconnectingWebsocket(path: string) {
    const existingWebsocket = this.websocketsByPath[path]
    if (existingWebsocket) {
      return existingWebsocket
    } else {
      const newWebsocket = new AutoReconnectingWebsocket(
        this.makeWebsocketURL(path),
        {
          mock: this.mock,
        },
      )
      this.websocketsByPath[path] = newWebsocket
      return newWebsocket
    }
  }

  /**
   * Connect to the motion state websocket(s) for a given motion group
   */
  async connectMotionStream(motionGroupId: string) {
    return await MotionStreamConnection.open(this, motionGroupId)
  }

  /**
   * Connect to the jogging websocket(s) for a given motion group
   */
  async connectJogger(motionGroupId: string) {
    return await JoggerConnection.open(this, motionGroupId)
  }

  async connectMotionGroups(
    motionGroupIds: string[],
  ): Promise<ConnectedMotionGroup[]> {
    const { instances } = await this.api.controller.listControllers()

    return Promise.all(
      motionGroupIds.map((motionGroupId) =>
        ConnectedMotionGroup.connect(this, motionGroupId, instances),
      ),
    )
  }

  async connectMotionGroup(
    motionGroupId: string,
  ): Promise<ConnectedMotionGroup> {
    const motionGroups = await this.connectMotionGroups([motionGroupId])
    return motionGroups[0]!
  }
}
